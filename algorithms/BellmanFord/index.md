# Алгоритм Беллмана-Форда 



Алгоритм Беллмана-Форда находит в ориентированном графе кратчайшие пути от исходной вершины до всех остальных. В отличие от алгоритма Дейкстры, в алгоритме Беллмана-Форда могут быть рёбра с отрицательным весом. Однако сложность алгоритма Дейкстры O(NlogN), а Беллмана-Фода O(NM).

![image](https://user-images.githubusercontent.com/101891316/172057311-daf6a349-5b72-4291-bbca-0827f1fcbc19.png)
 
 ### Перейдём к сути. Что же из себя представляет этот Беллман-Форд?.. :flushed:
 

***Вход:*** граф и начальная вершина (назовем её start)

***Выход:*** кратчайшее расстояние до всех вершин от start

**1)** Создаётся массив dist[n], где n – количество вершин. На этом шаге расстояния от исходной вершины до всех остальных инициализируются как бесконечность, а расстояние до самой start = 0 (заполняем массив соответствующими значениями)

**2)** Далее вычисляются самые короткие расстояния. Следующие шаги выполняются n–1 раз (для каждого ребра u-v):
``` 
Если dist[v] > dist[u] + вес ребра uv, то обновите dist[v]
dist[v] = dist[u] + вес ребра uv
```

**3)** На этом этапе сообщается, присутствует ли в графе цикл отрицательного веса. Для каждого ребра u-v:
```
Если dist[v] > dist[u] + вес ребра uv, то в графе присутствует цикл отрицательного веса.
```
Идея шага 3 заключается в том, что шаг 2 гарантирует кратчайшее расстояние, если граф не содержит цикла отрицательного веса. Если мы снова переберем все ребра и получим более короткий путь для любой из вершин, это будет сигналом присутствия цикла отрицательного веса. См. картинку :point_down:

![image](https://user-images.githubusercontent.com/101891316/172057876-677efdad-7849-4daa-8c7d-46310ac68081.png)

Для закрепления рассмотрим _примерчик_ 

Пусть начальная вершина равна 0. Примите все расстояния за бесконечные, кроме расстояния до самой start. Общее число вершин в графе равно 5, поэтому все ребра нужно пройти 4 раза.

![image](https://user-images.githubusercontent.com/101891316/172058119-19d7711e-9e0a-401b-8321-a2be19636677.png)

Пусть ребра отрабатываются в следующем порядке: (B, E), (D, B), (B, D), (A, B), (A, C), (D, C), (B, C), (E, D). Мы получаем следующие расстояния, когда проход по ребрам был совершен первый раз. Первая строка показывает начальные расстояния, вторая строка показывает расстояния, когда ребра (B, E), (D, B), (B, D) и (A, B) обрабатываются. Третья строка показывает расстояние при обработке (A, C). Четвертая строка показывает, что происходит, когда обрабатываются (D, C), (B, C) и (E, D).

![image](https://user-images.githubusercontent.com/101891316/172058192-61baeaf5-16ee-431f-aaa7-435e3fc1aeab.png)

Первая итерация гарантирует, что все самые короткие пути будут не длиннее пути в 1 ребро. Мы получаем следующие расстояния, когда будет совершен второй проход по всем ребрам (в последней строке показаны конечные значения).

![image](https://user-images.githubusercontent.com/101891316/172058227-7341f46b-c8eb-44f9-828f-9b145742673d.png)

Вторая итерация гарантирует, что все кратчайшие пути будут иметь длину не более 2 ребер. Алгоритм проходит по всем ребрам еще 2 раза. Расстояния минимизируются после второй итерации, поэтому третья и четвертая итерации не обновляют значения расстояний.

На этом все. Удачи на экзамене :) 

![image](https://user-images.githubusercontent.com/101891316/172058637-9f15e0dd-7799-4141-9f67-7200f2fd9e6a.png)




