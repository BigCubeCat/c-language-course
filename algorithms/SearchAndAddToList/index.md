## Алгоритм поиска значения в списке, реализованном через массив значений элементов.
### Чем отличается список *реализованный через структуру с указателем* и *через массив*?

Реализация через структуру с указателем выглядит вот так:
```c
struct list {
    int val; 
    list* next; 
}
```
Где ```list* next``` - указатель на следующий элемент.

Для массива структура выглядит так:
```c
struct list {
    int val;
    size_t next; 
}
```
Где ```size_t next```, равен индексу следующего элемента.

Например, элементы:

```[{val0, 1}, {val1, 3}, {val2, 0}, {val3, 2}]```

образуют список из элементов массива 0 -> 1 -> 3 -> 2

А теперь приступим к самим алгоритмам поиска:
### Алгоритмы:
Поскольку мы работаем в массиве структур, для поиска мы можем использовать [линейный поиск по массиву](/algorithms/SearchArray/index.md),

либо вспомнить что мы работаем в списке, и пробежаться по списку в поисках значения.

Несмотря на то что мы работаем в массиве, лучше чем за линейное время найти значение не удастся,

поскольку нам необходимо сохранить структуированность списка.

## Алгоритм добавления значения в список, реализованном через массив значений элементов.
Пусть count - количество элементов в массиве, size - размер массива,

Тогда при добавлении в массив, будем заносить под индексом count (count < size). Осталось определиться с указателями.

Для добавления в Nую позицию списка, нам достаточно N-1 раз пройтись по указателям в массиве,

затем изменить указатель N-1го элемента на добавляемый, а указатель добавляемого на *next* указатель N-1го.

## Алгоритм поиска значения в списке, реализованном через структуру с указателями.

Поскольку по списку реализованном только на указателях, поиск значений осуществим только перебором,

соотвественно необходимо просто пройтись по всему списку, в поиске значения.

## Алгоритм добавления значения в список, реализованном через структуру с указателями.

Алгоритм добавления схож с добавлением на массиве, но вот только в массив мы добавляли элемент в конец,

из-за чего мы словно прыгали по массиву для нахождения элемента, но вот реализация через структуру с

указателями более структуированна, поэтому при добавлении мы просто будем выделять память под новый узел,

и словно вмещать Nый элемент между N-1м и N+1м, просто меняя указатель N-1го на N, а указатель Nго на N+1й.

Я думаю так-же стоит упомянуть про стек и очередь: [Тут скоро будет статья]()
