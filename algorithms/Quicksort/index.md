# Алгоритм быстрой сортировки Хоара
Этот алгоритм, чаще называемый просто «быстрая сортировка» (Quicksort), придуман английским ученым Чарльзом Хоаром в 1960 году и использует стратегию «разделяй и властвуй».
Шаги алгоритма таковы:
1. Выбираем в массиве некоторый элемент, который будем называть опорным элементом.
2. Операция разделения массива: реорганизуем массив таким образом, чтобы все элементы, меньшие или равные опорному элементу, оказались слева от него, а все элементы, большие опорного — справа от него. Обычный алгоритм этой операции:
-	Два индекса — l и r, приравниваются к минимальному и максимальному индексу разделяемого массива соответственно.
-	Вычисляется индекс опорного элемента m.
-	Индекс l последовательно увеличивается до m до тех пор, пока l-й элемент не превысит опорный.
-	Индекс r последовательно уменьшается до m до тех пор, пока r-й элемент не окажется меньше либо равен опорному.
-	Если r = l — найдена середина массива — операция разделения закончена, оба индекса указывают на опорный элемент.
-	Если l < r — найденную пару элементов нужно обменять местами и продолжить операцию разделения с тех значений l и r, которые были достигнуты. Следует учесть, что если какая-либо граница (l или r) дошла до опорного элемента, то при обмене значение m изменяется на r-й или l-й элемент соответственно.
3. Рекурсивно упорядочиваем подмассивы, лежащие слева и справа от опорного элемента.
4. Базой рекурсии являются наборы, состоящие из одного или двух элементов. Первый возвращается в исходном виде, во втором, при необходимости, сортировка сводится к перестановке двух элементов. Все такие отрезки уже упорядочены в процессе разделения.
Поскольку в каждой итерации (на каждом следующем уровне рекурсии) длина обрабатываемого отрезка массива уменьшается, по меньшей мере, на единицу, терминальная ветвь рекурсии будет достигнута всегда и обработка гарантированно завершится.
## Давайте рассмотрим пример:
```
Дано множество
{9,6,3,4,10,8,2,7}
```
Берем 9 в качестве базового элемента. Сравниваем 9 с противоположностоящим элементом, в данном случае это 7. 7 меньше, чем 9, следовательно элементы меняются местами.
```
{7,6,3,4,10,8,2,9}
```
Далее начинаем последовательно сравнивать элементы с 9, и менять их местами в зависимости от сравнения.
```
{7,6,3,4,10,8,2,9}
{7,6,3,4,10,8,2,9}
{7,6,3,4,10,8,2,9}
{7,6,3,4,9,8,2,10} - 9 и 10 меняем местами.
{7,6,3,4,8,9,2,10} - 9 и 8 меняем местами.
{7,6,3,4,8,2,9,10} - 2 и 9 меняем местами.
```
После такого перебрасывания элементов весь массив разбивается на два подмножетсва, разделенных элементом 9.
```
{7,6,3,4,8,2}
{10}
```
Далее по уже отработанному алгоритму сортируются эти подмножества. Подмножество из одного элемента естественно можно не сортировать. Выбираем в первом подмножестве базовый элемент 7.
```
{7,6,3,4,8,2}

{2,6,3,4,8,7} - меняем местами 2 и 7.
{2,6,3,4,8,7}
{2,6,3,4,8,7}
{2,6,3,4,8,7}
{2,6,3,4,7,8}- меняем местами 7 и 8
```
Получили снова два подмножества.
```
{2,6,3,4}
{8}
```
А дальше все происходит аналогично... В результате можно родить такую программу %) :
```c
int QuickSort(int *array, int left, int right)
{
	long base, opposite, p;
	int c;
	base=left;
	opposite=right;
	while (base!=opposite){
		if ((array[base]>array[opposite])^(base>opposite)){

			c=array[base];
			array[base]=array[opposite];
			array[opposite]=c;

			p=base;
			base=opposite;
			if (p<opposite)
				opposite=p+1; else opposite=p-1;
		} else {
			if (base<opposite)
				opposite--; else opposite++;
		};
	};

	if (left<base-1) QuickSort(array,left,base-1);
	if (base+1<right) QuickSort(array,base+1,right);
};
```
