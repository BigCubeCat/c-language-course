![markdown logo](https://i.ytimg.com/vi/Nygib9tILjg/maxresdefault.jpg)

# Алгоритм Дейкстры

Алгоритм ~~Дийкстры~~ ***Дейкстры*** — алгоритм на графах, изобретённый нидерландским ученым Э. Дейкстрой в 1959 году.
Находит кратчайшее расстояние от одной из вершин графа до всех остальных. Работает только для графов без рёбер отрицательного веса.


## Чтобы понять суть алгоритма, лучше всего рассмотреть его действие на наглядном примере:


Пусть требуется найти кратчайшие расстояния от 1-й вершины до всех остальных.


Кружками обозначены вершины, линиями – пути между ними (ребра графа).
В кружках обозначены номера вершин, над ребрами обозначен их вес – длина пути.
Рядом с каждой вершиной красным обозначена метка – длина кратчайшего пути в эту вершину из вершины 1.

![markdown logo](https://prog-cpp.ru/wp-content/uploads/2014/05/deikstra1.png)

### Инициализация

Метка самой вершины 1 полагается равной 0, метки остальных вершин – недостижимо большое число (в идеале — бесконечность).
Это отражает то, что расстояния от вершины 1 до других вершин пока неизвестны. Все вершины графа помечаются как непосещенные.

![markdown logo](https://prog-cpp.ru/wp-content/uploads/2014/05/deikstra2.png)

### Первый шаг

Минимальную метку имеет вершина 1. Её соседями являются вершины 2, 3 и 6. Обходим соседей вершины по очереди.

Первый сосед вершины 1 – вершина 2, потому что длина пути до неё минимальна.
Длина пути в неё через вершину 1 равна сумме кратчайшего расстояния до вершины 1 (значению её метки) и длины ребра, идущего из 1-й во 2-ю, то есть 0 + 7 = 7. 
Это меньше текущей метки вершины 2 (10000), поэтому новая метка 2-й вершины равна 7.

![markdown logo](https://prog-cpp.ru/wp-content/uploads/2014/05/deikstra3.png)

Аналогично находим длины пути для всех других соседей (вершины 3 и 6).

Все соседи вершины 1 проверены.
Текущее минимальное расстояние до вершины 1 считается окончательным и пересмотру не подлежит.
Вершина 1 отмечается как посещенная.

### Второй шаг

Шаг 1 алгоритма повторяется. Снова находим «ближайшую» из непосещенных вершин. Это вершина 2 с меткой 7.

Снова пытаемся уменьшить метки соседей выбранной вершины, пытаясь пройти в них через 2-ю вершину. Соседями вершины 2 являются вершины 1, 3 и 4.

Вершина 1 уже посещена. Следующий сосед вершины 2 — вершина 3, так как имеет минимальную метку из вершин, отмеченных как не посещённые.
Если идти в неё через 2, то длина такого пути будет равна 17 (7 + 10 = 17). Но текущая метка третьей вершины равна 9, а 9 < 17, поэтому метка не меняется.

![markdown logo](https://prog-cpp.ru/wp-content/uploads/2014/05/deikstra4.png)

Ещё один сосед вершины 2 — вершина 4. Если идти в неё через 2-ю, то длина такого пути будет равна 22 (7 + 15 = 22). 
Поскольку 22<10000, устанавливаем метку вершины 4 равной 22.

Все соседи вершины 2 просмотрены, помечаем её как посещенную.

### Третий шаг

Повторяем шаг алгоритма, выбрав вершину 3. После её «обработки» получим следующие результаты.

![markdown logo](https://prog-cpp.ru/wp-content/uploads/2014/05/deikstra5.png)

### Четвертый шаг

![markdown logo](https://prog-cpp.ru/wp-content/uploads/2014/05/deikstra6.png)

### Пятый шаг

![markdown logo](https://prog-cpp.ru/wp-content/uploads/2014/05/deikstra7.png)

### Шестой шаг

![markdown logo](https://prog-cpp.ru/wp-content/uploads/2014/05/deikstra8.png)

#### Таким образом, кратчайшим путем из вершины 1 в вершину 5 будет путь через вершины **1 — 3 — 6 — 5**, поскольку таким путем мы набираем минимальный вес, равный 20.

### Вывод кратчайшего пути

Мы знаем длину пути для каждой вершины, и теперь будем рассматривать вершины с конца.
Рассматриваем конечную вершину (в данном случае — вершина **5**), и для всех вершин, с которой она связана, находим длину пути,
вычитая вес соответствующего ребра из длины пути конечной вершины.</br>
Так, вершина **5** имеет длину пути **20**. Она связана с вершинами **6** и **4**.</br>
Для вершины **6** получим вес **20 — 9 = 11 (совпал).**</br>
Для вершины **4** получим вес **20 — 6 = 14 (не совпал).**</br>
Если в результате мы получим значение, которое совпадает с длиной пути рассматриваемой вершины (в данном случае — вершина **6**),
то именно из нее был осуществлен переход в конечную вершину.
Отмечаем эту вершину на искомом пути.</br>
Далее определяем ребро, через которое мы попали в вершину **6**. И так пока не дойдем до начала.
Если в результате такого обхода у нас на каком-то шаге совпадут значения для нескольких вершин,
то можно взять любую из них — несколько путей будут иметь одинаковую длину.

### Реализация алгоритма

```C
#include <stdio.h>
#include <stdlib.h>
#define SIZE 6
int main()
{
  int a[SIZE][SIZE]; // матрица связей
  int d[SIZE]; // минимальное расстояние
  int v[SIZE]; // посещенные вершины
  int temp, minindex, min;
  int begin_index = 0;
  system("chcp 1251");
  system("cls");
  // Инициализация матрицы связей
  for (int i = 0; i<SIZE; i++)
  {
    a[i][i] = 0;
    for (int j = i + 1; j<SIZE; j++) {
      printf("Введите расстояние %d - %d: ", i + 1, j + 1);
      scanf("%d", &temp);
      a[i][j] = temp;
      a[j][i] = temp;
    }
  }
  // Вывод матрицы связей
  for (int i = 0; i<SIZE; i++)
  {
    for (int j = 0; j<SIZE; j++)
      printf("%5d ", a[i][j]);
    printf("\n");
  }
  //Инициализация вершин и расстояний
  for (int i = 0; i<SIZE; i++)
  {
    d[i] = 10000;
    v[i] = 1;
  }
  d[begin_index] = 0;
  // Шаг алгоритма
  do {
    minindex = 10000;
    min = 10000;
    for (int i = 0; i<SIZE; i++)
    { // Если вершину ещё не обошли и вес меньше min
      if ((v[i] == 1) && (d[i]<min))
      { // Переприсваиваем значения
        min = d[i];
        minindex = i;
      }
    }
    // Добавляем найденный минимальный вес
    // к текущему весу вершины
    // и сравниваем с текущим минимальным весом вершины
    if (minindex != 10000)
    {
      for (int i = 0; i<SIZE; i++)
      {
        if (a[minindex][i] > 0)
        {
          temp = min + a[minindex][i];
          if (temp < d[i])
          {
            d[i] = temp;
          }
        }
      }
      v[minindex] = 0;
    }
  } while (minindex < 10000);
  // Вывод кратчайших расстояний до вершин
  printf("\nКратчайшие расстояния до вершин: \n");
  for (int i = 0; i<SIZE; i++)
    printf("%5d ", d[i]);

  // Восстановление пути
  int ver[SIZE]; // массив посещенных вершин
  int end = 4; // индекс конечной вершины = 5 - 1
  ver[0] = end + 1; // начальный элемент - конечная вершина
  int k = 1; // индекс предыдущей вершины
  int weight = d[end]; // вес конечной вершины

  while (end != begin_index) // пока не дошли до начальной вершины
  {
    for (int i = 0; i<SIZE; i++) // просматриваем все вершины
      if (a[i][end] != 0)   // если связь есть
      {
        int temp = weight - a[i][end]; // определяем вес пути из предыдущей вершины
        if (temp == d[i]) // если вес совпал с рассчитанным
        {                 // значит из этой вершины и был переход
          weight = temp; // сохраняем новый вес
          end = i;       // сохраняем предыдущую вершину
          ver[k] = i + 1; // и записываем ее в массив
          k++;
        }
      }
  }
  // Вывод пути (начальная вершина оказалась в конце массива из k элементов)
  printf("\nВывод кратчайшего пути\n");
  for (int i = k - 1; i >= 0; i--)
    printf("%3d ", ver[i]);
  getchar(); getchar();
  return 0;
}
```
