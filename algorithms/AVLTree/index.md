# Алгоритм вставки элемента в АВЛ-дерево. Длинный и короткий повороты.

Содержание:

1. АВЛ дерево – это
1. Вставка элемента
1. Малые повороты – левый и правый
1. Большие повороты – левый и правый
1. Почему АВЛ дерево круто 
____


## 1. АВЛ дерево

  Для начала давайте вспомним что такое двоичное дерево поиска? Д.д.п. – это структура данных, обладающая следующими свойствами:
+	оба поддерева — левое и правое — являются двоичными деревьями поиска;
+	у всех узлов левого поддерева произвольного узла X значения меньше, чем значение самого узла X;
+	у всех узлов правого поддерева произвольного узла X значения больше либо равны значению самого узла X.

  Если быть проще: значение у левой вершины (ребёнка) меньше родителя, а у правой вершины (ребёнка) больше или равно родителю. 

<p align="left">
<img src="image/1.jpg" widdth="100" height="200">
</p>
 
  Теперь можно сказать, АВЛ дерево – это двоичное дерево поиска с одним дополнением, оно является сбалансированным: для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу.

<p align="left">
<img src="image/2.jpg" widdth="120" height="260">
</p>

  Поиск нужного элемента производится как в обычном двоичном дереве, главным отличием является алгоритм добавления новой вершины, поскольку должно сохраниться свойство сбалансированности высоты. Для этого используют повороты, о которых будет сказано чуть ниже.

Структура узла:
```c++
struct AVLTree {
  int val;
  int height;
  AVLTree* left;
  AVLTree* right;
};
```
____


## 2. Вставка элемента


  Первый случай: дерево изначально пустое – новый блок стал корнем.

  Второй: ищем место куда добавить элемент – спускаемся вниз по дереву, пока не найдем нужное место (справа от узла - если значение переменной больше, слева - если меньше). Нашли – закрепили. 

  Реализация с помощью рекурсии кажется самой приятной.

  А вот тут и начинаются различия от обычного дерева: добавив новый элемент может случиться так, что высота слева и справа будет отличаться больше чем на 1. Нужно делать балансировку для каждого поддерева, выходя вверх из рекурсии. Важно также не забывать обновлять высоту. 
```c++
AVLTree* AppentToTree(AVLTree* BlockNow, int val) {
              . . .    //поиск места куда добавить + рекурсия 
    BlockNow = MakeATurn(BlockNow);
    BlockNow->height = MaxHeight(BlockNow) + 1;
    return BlockNow;
}
```
____


## 3. Малые повороты 

 Пусть мы добавили элемент в левую часть дерева. У нас образовалась проблема – разница высот стала больше 1 => надо сделать малый правый поворот относительно вершины p: 

<p align="center">
<img src="image/3.jpg" widdth="140" height="280">
</p>

  Псевдокод:
```c++
AVLTree* RightSmallTurn(AVLTree* p) { // правый поворот вокруг p
      AVLTree* q = p->left;
      p->left = q->right;
      q->right = p;
  
      //также надо изменить высоту у узла p и q
      return q;
}
```
  Левый поворот реализуется аналогично.
____


## 4. Большие повороты


  Реализуются на основе двух маленьких поворотов. Какой именно надо делать зависит от того, какие в данный момент высоты у поддеревьев ниже. Описывать словами все варианты не думаю хорошей идеей, ниже рассмотрены все случаи:
```c++
AVLTree* MakeATurn(AVLTree* BlockNow) {
    if (abs(Height(BlockNow->right) - Height(BlockNow->left)) <= 1) {
        return BlockNow;  // все ок, крутить не надо
    } else {
        if (Height(BlockNow->right) - Height(BlockNow->left) > 1 ) {
            if (Height(BlockNow->right->left)  <= Height(BlockNow->right->right)) {
                BlockNow = LeftSmallTurn(BlockNow);
            } else {
                BlockNow = LeftBigTurn(BlockNow);
            }
        } else {
            if (Height(BlockNow->left->right) <= Height(BlockNow->left->left)) {
                BlockNow = RightSmallTurn(BlockNow);
            } else {
                BlockNow = RightBigTurn(BlockNow);
            }
        }
    }
    return BlockNow;
}
```
  Где функция Height возращает высоту поддерева. Внутри этой функции надо сделать проверку на то, что вершина, которую мы передаем в функцию, существует (иначе мы не сможем взять из нее высоту). В противном случае возращаем 0.

  На примере большого левого:

<p align="center">
<img src="image/4.jpg" widdth="140" height="280">
</p>

  А вот и весь код поворота:
```c++
AVLTree* LeftBigTurn(AVLTree* Block) {
    Block->right = RightSmallTurn(Block->right);
    Block = LeftSmallTurn(Block);
    return Block;
}
```

  Большой правый делается аналогично.
____

## 5. Почему АВЛ дерево круто

Основной выйгрыш, получаемый от использование АВЛ дерева, является поиск в нём элемента.

Пример: возьмём пустое двоичное дерево. Сложность поиска в таком виде напрямую зависит от высоты пути до нужного элемента - О(h). Если мы рассмотрим монотонно возрастающую последовательность (1, 2, 3, 4 ...) то заметим - все элементы будут добавляться в правую ветку (образуется "сосиска"), высота станет h = n-1 и сложность поиска элемента будет не лучше обыного поиска в массиве.

И тут нам на помощь приходит сбалансированное АВЛ дерево, не позволяющее появиться "сосиске" т.к. главное правило: разность высот не больше 1 =) 
____

  По традиции, мем: 
<p align="center">
<img src="image/мем.jpg" widdth="140" height="280">
</p>
