# Алгоритм вставки элемента в АВЛ-дерево. Длинный и короткий повороты.

Содержание:

1. АВЛ дерево – это
1. Вставка элемента
1. Малые повороты – левый и правый
1. Большие повороты – левый и правый
____


## 1. АВЛ дерево

  Для начала давайте вспомним что такое двоичное дерево поиска? Д.д.п. – это структура данных, обладающая следующими свойствами:
•	оба поддерева — левое и правое — являются двоичными деревьями поиска;
•	у всех узлов левого поддерева произвольного узла X значения меньше, чем значение самого узла X;
•	у всех узлов правого поддерева произвольного узла X значения больше либо равны, значения самого узла X.

  Если быть проще: значение у левой вершины (ребёнка) меньше родителя, а у правой вершины (ребёнка) больше или равно родителю. 

<p align="left">
<img src="image/1.jpg" widdth="100" height="200">
</p>
 
  Теперь можно сказать, АВЛ дерево – это двоичное дерево поиска с одним дополнением, оно является сбалансированным: для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу.

<p align="left">
<img src="image/2.jpg" widdth="120" height="260">
</p>

  Поиск нужного элемента производится как в обычном двоичном дереве, главным отличием является алгоритм добавления новой вершины, поскольку должно сохраниться свойство сбалансированности высоты. Для этого используют повороты, о которых будет сказано чуть ниже.

Структура узла:
```c++
struct AVLTree {
  int val;
  int height;
  AVLTree* left;
  AVLTree* right;
};
```
____


## 2. Вставка элемента

  Добавление элемента происходит как в двоичном дереве.

  Первый случай: дерево изначально пустое – новый блок стал корнем.

  Второй: ищем место куда добавить элемент – спускаемся вниз по дереву, пока не найдем нужное место (справа от узла - если значение переменной больше, слева - если меньше). Нашли – закрепили. 

  В лабораторной реализовывал с помощью рекурсии.

  А вот тут и начинаются различия от обычного дерева: добавив новый элемент может случиться так, что высота слева и справа будет отличаться больше чем на 1. Нужно делать балансировку для каждого поддерева, выходя вверх из рекурсии. Важно также не забывать обновлять высоту. 
```c++
AVLTree* AppentToTree(AVLTree* BlockNow, int val) {
              . . .    //поиск места куда добавить + рекурсия 
    BlockNow = MakeATurn(BlockNow);
    BlockNow->height = MaxHeight(BlockNow) + 1;
    return BlockNow;
}
```
____


## 3. Малые повороты 

  Рассмотрим ситуацию для правого малого поворота: 

<p align="center">
<img src="image/3.jpg" widdth="140" height="280">
</p>

  Псевдокод:
```c++
AVLTree* RightSmallTurn(AVLTree* p) { // правый поворот вокруг p
      AVLTree* q = p->left;
      p->left = q->right;
      q->right = p;
  
      //также надо изменить высоту у узла p и q
      return q;
}
```
  Левый поворот реализуется аналогично.
____


## 4. Большие повороты


  Реализуются на основе двух маленьких поворотов. Какой именно надо делать зависит от того, какие в данный момент высоты у поддеревьев ниже. Описывать словами все варианты не думаю хорошей идеей, ниже рассмотрены все случаи:
```c++
if (Height(BlockNow->right) - Height(BlockNow->left) > 1 ) {
    if (Height(BlockNow->right->left)  <= Height(BlockNow->right->right)) {
        BlockNow = LeftSmallTurn(BlockNow);
    } else {
        BlockNow = LeftBigTurn(BlockNow);
    }
} else {
    if (Height(BlockNow->left->right) <= Height(BlockNow->left->left)) {
        BlockNow = RightSmallTurn(BlockNow);
    } else {
        BlockNow = RightBigTurn(BlockNow);
    }
}
```
  Где функция Height возращает высоту поддерева.

  На примере большого левого:

<p align="center">
<img src="image/4.jpg" widdth="140" height="280">
</p>

  А вот и весь код поворота:
```c++
AVLTree* LeftBigTurn(AVLTree* Block) {
    Block->right = RightSmallTurn(Block->right);
    Block = LeftSmallTurn(Block);
    return Block;
}
```

  Большой правый делается аналогично.
____

  По традиции, мем: 
<p align="center">
<img src="image/мем.jpg" widdth="140" height="280">
</p>
