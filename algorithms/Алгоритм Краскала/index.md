# Алгоритм Краскала
## Формальная постановка задачи 

Имеется следующий неориентированный взвешенный граф. Назовем остовным деревом подграф, содержащий все вершины исходного графа, который является деревом. И задача состоит в том, чтобы найти такое остовное дерево, сумма рёбер которого минимальна. 

## Неформальная постановка задачи 

Представьте исходный граф без рёбер, теперь вам нужно как-то соединить все вершины между собой, чтобы можно было бы попасть из любой вершины в другую, не имея при этом циклов в получившемся графе с минимально возможной суммой весов включенных рёбер 

## Сам алгоритм 

Механизм, по которому работает данный алгоритм, очень прост. На входе имеется пустой подграф, который и будем достраивать до потенциального минимального остовного дерева. Будем рассматривать только связные графы, в другом случае при применении алгоритма Краскала мы будем получать не минимальное остовное дерево, а просто остовной лес. 

- Вначале мы производим сортировку рёбер по неубыванию по их весам. 

- Добавляем i-ое ребро в наш подграф только в том случае, если данное ребро соединяет две разные компоненты связности, одним из которых является наш подграф. То есть, на каждом шаге добавляется минимальное по весу ребро, один конец которого содержится в нашем подграфе, а другой - еще нет. 

- Алгоритм завершит свою работу после того, как множество вершин нашего подграфа совпадет с множеством вершин исходного графа. 

Данный алгоритм называется жадным из-за того, что мы на каждом шаге пытаемся найти оптимальный вариант, который приведет к оптимальному решению в целом. 

## Разбор конкретного примера по шагам 

Из представленного сверху графа, выпишем все его ребра в отсортированном порядке: 
``` 
1) D <--> B; w = 2 
2) D <--> C; w = 6 
3) A <--> B; w = 7 
4) A <--> C; w = 8 
5) C <--> E; w = 9 
6) D <--> F; w = 9 
7) F <--> E; w = 10 
8) B <--> C; w = 11 
9) D <--> E; w = 11 
 ```
И начнем по списку добавлять эти ребра в наш остов: 

*Подграф после добавления 1-го ребра:*

![Alt-текст](https://habrastorage.org/r/w1560/getpro/habr/upload_files/1c7/d49/fe1/1c7d49fe118969ad226311e1a6c07a81.png)
 

*Подграф после добавления 2-го и 3-го рёбер:*

![Alt-текст](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c5f/c00/fde/c5fc00fde95bfdcf65d49870b95ede6d.png)

При добавлении в наше остовное дерево ребра A <--> C, как вы можете заметить, образовывается цикл, поэтому мы просто пропускаем данное ребро. 

По итогу у нас образовывается следующий подграф, и как вы заметили, мы соединили все вершины ребрами с минимально-возможными весами, а значит, нашли минимальное остовное дерево для нашего исходного графа. 

*Минимальный остов:*

![Alt-текст](https://habrastorage.org/r/w1560/getpro/habr/upload_files/12e/4f3/b2e/12e4f3b2e923cd1b2645f230068aba49.png)

Проводим проверку с помощью встроенного алгоритма для нахождения MST на graphonline, и видим, что подграфы идентичны. 
И да, из-за того, что при равенстве весов рёбер мы можем выбрать любое из них, конечные подграфы, являющиеся минимальными остовными деревьями, могут различаться с точностью до некоторых рёбер. 

*Провели проверку:*

![Alt-текст](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a40/a78/ec7/a40a78ec73132ab902da758a4249cc4f.png)

Суммарный вес искомого MST равен 33. 

## Реализация 

Реализовать представленный алгоритм проще всего с помощью СНМ(система непересекающихся отрезков). 
 
Вначале, как мы уже раннее говорили, необходимо отсортировать ребра по неубыванию по их весам. Далее с помощью вызовов функции make_set()мы каждую вершину можем поместить в свое собственное дерево, то есть, создаем некоторое множество подграфов. Дальше итерируемся по всем ребрам в отсортированном порядке и смотрим, принадлежат ли инцидентные вершины текущего ребра разным подграфам с помощью функции find_set() или нет, если оба конца лежат в разных компонентах, то объединяем два разных подграфа в один с помощью функции union_sets(). 

## Код: 
### Первый вариант
```c
#include <stdio.h>
#include <stdlib.h>
 
int NV;                 // Количество вершин в графе
int NE;                 // Количество ребер в графе
 
#define MAX_NODES 100  // Максимальное количество вершин
#define MAX_EDGES 10   // Максимальное количество ребер в графе
 
struct edge_t {
   int n1,n2;  // направление
   int w;      // вес ребра
} edges[MAX_EDGES];  // Ребра графа
 
int nodes[MAX_NODES];  // Вершины графа.  Значение - "верхняя вершина"
 
// Функция "сравнения" двух ребер, используемая для сортировки
int cmp(const void *a,const void *b){   
    edge *c=(edge*)a, *d=(edge*)b;
   return c->w - d->w;
}
 
int last_n;
 
// Функция получает цвет вершины n-й по порядку.
// если nodes[n] < 0, то вершина n имеет цвет nodes[n]
// если nodes[n] >= 0, то вершина n имеет цвет такой же, 
// как и вершина с номером nodes[n]
int getColor(int n){
   int c;
   if (nodes[n]<0)
      return nodes[last_n=n];
   c = getColor(nodes[n]);
   nodes[n] = last_n;
   return c;
}
 
int main(){
   int i;
   // Считываем вход
   scanf ("%d %d", &NV, &NE);
   for(i = 0; i < N; i++) nodes[i] = -1-i;
 
   for(i = 0; i < NE; i++)
      scanf("%d %d %d", &edges[i].n1, &edges[i].n2, &edges[i].w);
 
   // Алгоритм Крускала
 
   // Сортируем все ребра в порядке возрастания весов
   qsort(edges, NE, sizeof(edge_t), cmp); 
 
   for(i = 0; i < NE; i++){ // пока не прошли все ребра
      int c2 = getColor(edges[i].n2);
      if ( getColor (edges[i].n1) != c2 ){  
         // Если ребро соединяет вершины различных цветов-мы его добавляем
         // и перекрашиваем вершины
         nodes [last_n] = edges[i].n2;
         printf ("%d %d %d\n", edges[i].n1, edges[i].n2, edges[i].w);
      }
   }
   return 0;
}
```
### Второй вариант:
```c
#include <stdio.h>
#include <stdlib.h>
 
int NV;                 // Количество вершин в графе
int NE;                 // Количество ребер в графе
 
#define MAX_NODES 100  // Максимальное количество вершин
#define MAX_EDGES 10   // Максимальное количество ребер в графе
 
struct edge_t {
   int n1,n2;  // направление
   int w;      // вес ребра
} edges[MAX_EDGES];  // Ребра графа
 
int nodes[MAX_NODES];  // Вершины графа.  Значение - "верхняя вершина"
 
// Функция "сравнения" двух ребер, используемая для сортировки
int cmp(const void *a,const void *b){   
    edge *c=(edge*)a, *d=(edge*)b;
   return c->w - d->w;
}
 
int last_n;
 
// Функция получает цвет вершины n-й по порядку.
// если nodes[n] < 0, то вершина n имеет цвет nodes[n]
// если nodes[n] >= 0, то вершина n имеет цвет такой же, 
// как и вершина с номером nodes[n]
int getColor(int n){
   int c;
   if (nodes[n]<0)
      return nodes[last_n=n];
   c = getColor(nodes[n]);
   nodes[n] = last_n;
   return c;
}
 
int main(){
   int i;
   // Считываем вход
   scanf ("%d %d", &NV, &NE);
   for(i = 0; i < N; i++) nodes[i] = -1-i;
 
   for(i = 0; i < NE; i++)
      scanf("%d %d %d", &edges[i].n1, &edges[i].n2, &edges[i].w);
 
   // Алгоритм Крускала
 
   // Сортируем все ребра в порядке возрастания весов
   qsort(edges, NE, sizeof(edge_t), cmp); 
 
   for(i = 0; i < NE; i++){ // пока не прошли все ребра
      int c2 = getColor(edges[i].n2);
      if ( getColor (edges[i].n1) != c2 ){  
         // Если ребро соединяет вершины различных цветов-мы его добавляем
         // и перекрашиваем вершины
         nodes [last_n] = edges[i].n2;
         printf ("%d %d %d\n", edges[i].n1, edges[i].n2, edges[i].w);
      }
   }
   return 0;
}
```
## Полезные ссылки:
[Алгоритм Краскала на всех основных языках](https://forkettle.ru/vidioteka/programmirovanie-i-set/algoritmy-i-struktury-dannykh/108-sortirovka-i-poisk-dlya-chajnikov/5970-grafy-poisk-ostova-minimalnogo-ves)
