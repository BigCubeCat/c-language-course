# Система непересекающихся множеств (СНМ)
**СНМ** — структура данных, которая позволяет администрировать множество элементов, разбитое на непересекающиеся подмножества. При этом каждому подмножеству назначается его представитель — элемент этого подмножества. Применяется для хранения компонент связности в графах.

Данная структура данных определяется тремя операциями: 

**MakeSet(X)** — внести в структуру новый элемент X, создать для него множество размера 1 из самого себя.

**Find(X)** — возвратить представителя множества, которому принадлежит элемент X. В качестве представителя мы будем выбирать один элемент из этого множества. Гарантируется, что для двух элементов из одного и того же множества функция вернёт одного и того же представителя.

**Union(X, Y)** — объединить два множества, в которых лежат элементы X и Y, в одно.

Давайте разберём более подробно на рисунке:

<p align="left">
<img src="images/Пример СНМ4.png" alt="Пример СНМ" title="Пример СНМ">
</p>

# Реализация

- **MakeSet(X)**

  Чтобы создать новое дерево из элемента X, достаточно указать, что он является корнем собственного дерева, указывает сам на себя, и предка не имеет.
  ```C
  void MakeSet(int v) {
    dsu[v] = v;
  }
  ```
- **Find(X)**

  Представителем дерева будем считать его корень. То есть чтобы найти представителя необходимо рекурсивно подниматься по дереву пока не дойдём до корня (dsu[v] = v).
  ```C
  int Find(int v) {
    if (dsu[v] == v)
      return v;
    return Find(dsu[v]);
  }
  ```
  Но это еще не всё: такая наивная реализация в случае вырожденного дерева (когда дерево превратиться в длинную сосисочку) может работать за O(N), чего мы себе (как истинные программисты) позволить не можем.

  Вопрос, что же делать?

  Есть всего 2 варианта:

  - Каждый раз при поиске представителя каждый элемент который мы будем рассматривать перебрасывать на родителя родителя.
     ```C
      int Find(int v) {
        int temp = dsu[v];
        if (dsu[v] == v)
          return v;
        dsu[v] = dsu[dsu[v]];
        return Find(temp);
      }
      ```
  - Каждый раз при поиске представителя каждый элемент который мы будем рассматривать сразу прикреплять к представителю.
     ```C
      int Find(int v) {
        if (dsu[v] == v)
          return v;
        return dsu[v] = Find(dsu[v]);
      }
      ```
  НУЖНО ВЫБРАТЬ КАКУЮ-ТО---------------------------------------------

- **Union(X, Y)**

  Со слиянием двух деревьев всё немного сложнее. Найдем для начала корни обоих сливаемых деревьев с помощью уже написанной функции Find. Теперь для объединения деревьев достаточно просто подвесить один из корней (а с ним и все дерево) сыном к другому. Таким образом все элементы этого дерева автоматически станут принадлежать.

  Встает вопрос: какое дерево к какому подвешивать? Всегда выбирать какое-то одно, скажем, дерево X, не годится: легко подобрать пример, на котором после N объединений мы получим вырожденное дерево — одну ветку из N элементов.

  Поэтому будем хранить помимо предков еще один массив **Rank**. В нем для каждого дерева будет храниться верхняя граница его высоты — то есть длиннейшей ветви в нем. Заметьте, не сама высота — в процессе выполнения Find длиннейшая ветвь может самоуничтожиться, а тратить еще итерации на нахождение новой длиннейшей ветви слишком дорого. Поэтому для каждого корня в массиве Rank будет записано число, гарантированно больше или равное высоте его дерева.

  Теперь легко принять решении о слиянии: чтобы не допустить слишком длинных ветвей в DSU, будем подвешивать более низкое дерево к более высокому. Если их высоты равны — не играет роли, кого подвешивать к кому. Но тогда новому корню надо не забыть увеличить Rank.
  ```C
  void Union (int x, int y) {
      x = Find(x);
      y = Find(y);
      if (rank[x] < rank[y])
          p[x] = y;
      else
      {
          p[y] = x;
          if (rank[x] == rank[y])
                ++rank[x];
      }
  }
  ```
  Однако на практике оказывается, что можно и не тратить дополнительные O(N) памяти на махинации с рангами. Достаточно выбирать корень для переподвешивания **случайным образом** либо всегда брать первый — как ни удивительно, но такое решение дает на практике скорость, вполне сравнимую с оригинальной ранговой реализацией, ведь большая разница в высотах исчезнет всего за пару тройку вызовов Find от элементов добавленного дерева.

# Теперь поговорим о скорости

В силу применения двух эвристик (наших методов ускорения) скорость работы каждой операции сильно зависит от структуры дерева, а структура дерева — от списка выполненных до того операций. Кроме конечно же MakeSet — её время работы очевидно O(1). Для остальных двух скорость не так неочевидна.

Вырезка из Хабра:

“Роберт Тарьян доказал в 1975 г. замечательный факт: время работы как Find, так и Unite на лесе размера N есть O(α(N)).
Под α(N) в математике обозначается обратная функция Аккермана, то есть, функция, обратная для f(N) = A(N, N). Функция Аккермана A(N, M) известна тем, что у нее колоссальная скорость роста. К примеру, A(4, 4) = 22265536-3, это число поистине огромно. Вообще, для всех мыслимых практических значений N обратная функция Аккермана от него не превысит 5. Поэтому её можно принять за константу и считать O(α(N)) ≅ O(1).”

По итогу имеем:                                                               
MakeSet(X) — O(1).                                                                                    
Find(X) — O(1) амортизированно.                                                                             
Union(X, Y) — O(1) амортизированно.                                                                   
Расход памяти — O(N).                                           
