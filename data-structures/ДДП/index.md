# Дерево двоичного поиска 

***Бинарное дерево*** — это иерархическая структура данных, в которой каждый узел имеет значение (оно же является в данном случае и ключом) и ссылки на левого и правого потомка. Узел, находящийся на самом верхнем уровне (не являющийся чьим либо потомком) называется корнем. Узлы, не имеющие потомков (оба потомка которых равны NULL) называются листьями. 

***Двоичным деревом поиска (ДДП)*** называют дерево, все вершины которого упорядочены, каждая вершина имеет не более двух потомков (назовём их левым и правым), и все вершины, кроме корня, имеют родителя. Вершины, не имеющие потомков, называются листами. 
Подразумевается, что каждой вершине соответствует элемент или несколько элементов, имеющие некие ключевые значения, в дальнейшем именуемые просто ключами. 
![Alt-текст](https://andbas.com/content/images/2018/10/Binary_Search_Tree_-_Remove_Step_3.svg.png)
*ДДП позволяет выполнять следующие основные операции:*  

- Поиск вершины по ключу.  

- Определение вершин с минимальным и максимальным значением ключа.  

- Переход к предыдущей или последующей вершине, в порядке, определяемом ключами. ▫ Вставка вершины. 

- Удаление вершины. 

*Глубина дерева поиска*

- Двоичное дерево может быть логически разбито на уровни. Корень дерева является нулевым уровнем, потомки корня – первым уровнем, их потомки – вторым, и т.д. Глубина дерева это его максимальный уровень.  

- Каждую вершину дерева можно рассматривать как корень поддерева, которое определяется данной вершиной и всеми потомками этой вершины, как прямыми, так и косвенными. Поэтому о дереве можно говорить как о рекурсивной структуре. 

***Сбалансированное бинарное дерево поиска***

Это бинарное дерево поиска с логарифмической высотой. Данное определение скорее идейное, чем строгое.  В сбалансированном бинарном дереве поиска операции поиска, вставки и удаления выполняются за логарифмическое время (так как путь к любому листу от корня не более логарифма). В вырожденном случае несбалансированного бинарного дерева поиска, например, когда в пустое дерево вставлялась отсортированная последовательность, дерево превратится в линейный список, и операции поиска, вставки и удаления будут выполняться за линейное время. Поэтому балансировка дерева крайне важна. Технически балансировка осуществляется поворотами частей дерева при вставке нового элемента, если вставка данного элемента нарушила условие сбалансированности. 

Сбалансированное бинарное дерево поиска применяется, когда необходимо осуществлять быстрый поиск элементов, чередующийся со вставками новых элементов и удалениями существующих. В случае, если набор элементов, хранящийся в структуре данных фиксирован и нет новых вставок и удалений, то массив предпочтительнее. Потому что поиск можно осуществлять алгоритмом бинарного поиска за то же логарифмическое время, но отсутствуют дополнительные издержки по хранению и использованию указателей. Например, в С++ ассоциативные контейнеры set и map представляют собой сбалансированное бинарное дерево поиска. 

## Свойства упорядоченности ДДП 

- Если x – это произвольная вершина в ДДП, а вершина y находится в левом поддереве вершины x, то y.key <= x.key.  

- Если x – это произвольная вершина ДДП, а вершина y находится в правом поддереве вершины x, то y.key >= x.key.  

- Из свойства следует, что если y.key == x.key, то вершина y может находиться как в левом, так и в правом поддереве относительно вершины x. Необходимо помнить, что при наличии нескольких вершин с одинаковыми значениями ключа некоторые алгоритмы не будут работать правильно. Например, алгоритм поиска будет всегда возвращать указатель только на одну вершину. Эту проблему можно решить, храня элементы с одинаковыми ключами в одной и той же вершине в виде списка. 

## Способы обхода ДДП  

- Прямой обход: сначала обходится данная вершина, левое поддерево данной вершины, затем правое поддерево данной вершины.  

- Поперечный обход: сначала обходится левое поддерево данной вершины, затем данная вершина, затем правое поддерево данной вершины. Вершины при этом будут следовать в неубывающем (по ключам key) порядке.  

- Обратный обход: сначала обходится левое поддерево данной вершины, затем правое, затем данная вершина. 

## Тело ДДП
Обычно в качестве типа данных мы используем void* и далее передаём функции сравнения через указатели. В этот раз будем использовать пользовательский тип и макросы. 
```C
typedef int T; 

#define CMP_EQ(a, b) ((a) == (b)) 
#define CMP_LT(a, b) ((a) < (b)) 
#define CMP_GT(a, b) ((a) > (b)) 

typedef struct Node { 
    T data; 
    struct Node *left; 
    struct Node *right; 
    struct Node *parent; 
} Node; 
```
Сначала, как обычно, напишем функцию, которая создаёт новый узел. Она принимает в качестве аргументов значение и указатель на своего родителя. Корневой элемент не имеет родителя, значение указателя parent равно NULL. 
```C
Node* getFreeNode(T value, Node *parent) { 
    Node* tmp = (Node*) malloc(sizeof(Node)); 
    tmp->left = tmp->right = NULL; 
    tmp->data = value; 
    tmp->parent = parent; 
    return tmp; 
} 
```
## Вставка 

Возможны следующие ситуации: 

- Дерево пустое. В этом случае новый узел становится корнем ДДП. 

- Новое значение меньше корневого. В этом случае значение должно быть вставлено слева. Если слева уже стоит элемент, то повторяем эту же операцию, только в качестве корневого узла рассматриваем левый узел. Если слева нет элемента, то добавляем новый узел. 

- Новое значение больше корневого. В этом случае новое значение должно быть вставлено справа. Если справа уже стоит элемент, то повторяем операцию, только в качестве корневого рассматриваем правый узел. Если справа узла нет, то вставляем новый узел. 

Функция, добавляющая узел в дерево 

Два узла. Первый – вспомогательная переменная, чтобы уменьшить писанину, второй – тот узел, который будем вставлять. 
```C
Node *tmp = NULL; 
Node *ins = NULL; 
```
Проверяем, если дерево пустое, то вставляем корень 
```C
if (*head == NULL) { 
    *head = getFreeNode(value, NULL); 
    return; 
} 
```
Проходим по дереву и ищем место для вставки 
```C
tmp = *head; 
```
Пока не дошли до пустого узла 
```C
while (tmp) { 
```
Если значение больше, чем значение текущего узла 
```C
if (CMP_GT(value, tmp->data)) { 
```
Если при этом правый узел не пустой, то за корень теперь считаем правую ветвь и начинаем цикл сначала 
```C
if (tmp->right) { 
    tmp = tmp->right; 
    continue; 
```
Если правой ветви нет, то вставляем узел справа 
```C
} else { 
    tmp->right = getFreeNode(value, tmp); 
    return; 
} 
```
Также обрабатываем левую ветвь 
```C
    } else if (CMP_LT(value, tmp->data)) { 
        if (tmp->left) { 
            tmp = tmp->left; 
            continue; 
        } else { 
            tmp->left = getFreeNode(value, tmp); 
            return; 
        } 
    } else { 
        exit(2); 
    } 
} 
```
Весь код
```C
void insert(Node **head, int value) { 
    Node *tmp = NULL; 
    Node *ins = NULL; 
    if (*head == NULL) { 
        *head = getFreeNode(value, NULL); 
        return; 
    } 
    tmp = *head; 
    while (tmp) { 
        if (CMP_GT(value, tmp->data)) { 
            if (tmp->right) { 
                tmp = tmp->right; 
                continue; 
            } else { 
                tmp->right = getFreeNode(value, tmp); 
                return; 
            } 
        } else if (CMP_LT(value, tmp->data)) { 
            if (tmp->left) { 
                tmp = tmp->left; 
                continue; 
            } else { 
                tmp->left = getFreeNode(value, tmp); 
                return; 
            } 
        } else { 
            exit(2); 
        } 
    } 
} 
```
## Поиск в дереве 

Известно, что слева от узла располагается элемент, который меньше чем текущий узел. Из чего следует, что если у узла нет левого наследника, то он является минимумом в дереве. Таким образом, можно найти минимальный элемент дерева 
```C
Node* getMinNode(Node *root) { 
    while (root->left) { 
        root = root->left; 
    } 
    return root; 
} 
```
Аналогично, можно найти максимальный элемент 
```C
Node* getMaxNode(Node *root) { 
    while (root->right) { 
        root = root->right; 
    } 
    return root; 
} 
```
Опять же, если дерево хорошо сбалансировано, то поиск минимума и максимума будет иметь сложность порядка log(n), а в случае плохой балансировки стремится к n. 

Поиск нужного узла по значению похож на алгоритм бинарного поиска в отсортированном массиве. Если значения больше узла, то продолжаем поиск в правом поддереве, если меньше, то продолжаем в левом. Если узлов уже нет, то элемент не содержится в дереве. 
```C
Node *getNodeByValue(Node *root, T value) { 
    while (root) { 
        if (CMP_GT(root->data, value)) { 
            root = root->left; 
            continue; 
        } else if (CMP_LT(root->data, value)) { 
            root = root->right; 
            continue; 
        } else { 
            return root; 
        } 
    } 
    return NULL; 
} 
```
## Удаление узла 

Существует три возможных ситуации. 

- У узла нет наследников (удаляем лист). Тогда он просто удаляется, а его родитель обнуляет указатель на него. 
- У узла один наследник. В этом случае узел подменяется своим наследником. 
- У узла оба наследника. В этом случае узел не удаляем, а заменяем его значение на максимум левого поддерева. После этого удаляем максимум левого поддерева. (Напомню, что мы условились, что слева элементы меньше корневого). 

Наша функция будет принимать в качестве аргумента узел, который необходимо удалить. 
```C
if (target->left && target->right) { 
    //Оба наследника есть 
} else if (target->left) { 
    //Есть только левый наследник 
} else if (target->right) { 
    //Есть только правый наследник 
} else { 
    //Нет наследников 
} 
free(target);
```
Если нет наследников, то нужно узнать, каким поддеревом относительно родителя является узел 
```C
if (target == target->parent->left) { 
    target->parent->left = NULL; 
} else { 
    target->parent->right = NULL; 
} 
```
Если есть только правый или только левый наследник, подменяем наследником удаляемый узел. Перед этим нужно узнать, правым или левым наследником является удаляемый узел. 
```C
if (target == target->parent->left) { 
    target->parent->left = target->left; 
} else { 
    target->parent->right = target->left; 
} 
```
Или 
```C
if (target == target->parent->right) { 
    target->parent->right = target->right; 
} else { 
    target->parent->left = target->right; 
} 
```
Если оба наследника, то сначала находим максимум левого поддерева 
```C
Node *localMax = findMaxNode(target->left); 
```
Затем подменяем значение удаляемого узла на него 
```C
target->data = localMax->data; 
```
После чего удаляем этот узел 
```C
removeNodeByPtr(localMax); 
return;
```
Здесь мы использовали рекурсию, НО делать это очень плохо. Вызов будет всего один, так как известно, что максимум не содержит обоих наследников и является правым наследником своего родителя. Если хотите заменить вызов функции, то придётся скопировать оставшийся код. 
 
Весь код: 
```C
void removeNodeByPtr(Node *target) { 
    if (target->left && target->right) { 
        Node *localMax = findMaxNode(target->left); 
        target->data = localMax->data; 
        removeNodeByPtr(localMax); 
        return; 
    } else if (target->left) { 
        if (target == target->parent->left) { 
            target->parent->left = target->left; 
        } else { 
            target->parent->right = target->left; 
        } 
    } else if (target->right) { 
        if (target == target->parent->right) { 
            target->parent->right = target->right; 
        } else { 
            target->parent->left = target->right; 
        } 
    } else { 
        if (target == target->parent->left) { 
            target->parent->left = NULL; 
        } else { 
            target->parent->right = NULL; 
        } 
    } 
    free(target); 
} 
```
Упростим работу и сделаем обёртку вокруг функции, чтобы она удаляла узел по значению 
```C
void deleteValue(Node *root, T value) { 
    Node *target = getNodeByValue(root, value); 
    removeNodeByPtr(target); 
}
```
