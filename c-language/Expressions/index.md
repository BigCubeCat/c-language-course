# Выражения. Порядок вычисления выражения в языке Си. Приоритет и ассоциативность операции.
## Выражения.
Выражение представляет собой объединение операций и операндов. (Напомним, что операндом называется то, над чем выполняется операция.)
Простейшее выражение состоит из одного операнда, отталкиваясь от него, вы можете строить более сложные конструкции. 
Приведем несколько выражений.

-64+21

a*(b + c/d)/20

q = 5*2

х = ++q % 3 q > 3

Нетрудно заметить, что операнды могут быть константами, переменными или их сочетаниями.
## Порядок вычисления выражения в языке Си.
Обычно в языке Си не определяется, какие части сложного выражения будут вычисляться вначале. Например, в операторе:

apples = (5 + 3)*(9 + 6);

выражение 5 + 3 может быть вычислено до вычисления выражения 9 + 6, или наоборот
(Приоритеты, присвоенные операциям гарантатируют, что оба выражения будут вычислены перед выполнением операции умножения.)
Эта неопределенность была оставлена в языке, чтобы создатели компилятора имели возможность в конкретной системе осуществлять 
наиболее эффективный выбор. Исключением из этого правила (или его нарушением) является выполнение логических операций. **Язык 
Си гарантирует, что логические выражения вычисляются слева направо.** Более того, гарантируется также, что, как только обнаруживается 
элемент, значение которого устанавливает ложность всего выражения как целого, вычисление данного выражения прекращается. Это 
дает возможность использовать конструкции типа:

while((c = getchar( )) != EOF &&  с != 'n')

В результате вычисления первого подвыражения переменная с получает свое значение, которое затем можно 
использовать во втором подвыражении. Если бы такой порядок вычислений не гарантировался, при выполнении
программы компьютер, возможно, проверял бы истинность второго выражения перед нахождением значения переменной с.

Приведем еще один пример:

if (number !=0  && 12/number ==2) printf(" Число равно 5 или 6.n" );

Если значение переменной number равно 0, то все выражение ложно, и поэтому дальнейшее вычисление данного условного выражения прекращается. Это избавляет компьютер от последствий деления на нуль. Многие языки не обеспечивают выполнения подобного требования, и, выяснив, что number равно 0, компьютер переходит к проверке следующего условия.  

## Приоритет и ассоциативность операций.
Приоритет и ассоциативность операций языка Си влияют на порядок группирования операндов и вычисления операций в выражении.
Приоритет операций существен только при наличии нескольких операций, имеющих различный приоритет.
Выражения с более приоритетными операциями вычисляются первыми.

В таблице ниже приведены операции в порядке убывания приоритета. Операции, расположенные в одной строке таблицы,
или объединенные в одну группу, имеют одинаковый приоритет и одинаковую ассоциативность.
<p align="center">
<img src="images/Priority.png ">
</p>
Из таблицы следует, что операнды, представляющие вызов функции, индексное выражение,
выражение выбора элемента и выражение в скобках, имеют наибольший приоритет и ассоциативность слева направо.
Приведение типа имеет тот же приоритет и порядок выполнения, что и унарные операции.

Выражение может содержать несколько операций одного приоритета. Когда несколько операций одного и того же уровня приоритета
появляются в выражении, то они применяются в соответствии с их ассоциативностью — либо справа налево, либо слева направо.

Мультипликативные, аддитивные и поразрядные операции обладают свойством коммутативности.
Это значит, что результат вычисления выражения, включающего несколько коммутативных операций одного и того же приоритета,
не зависит от порядка выполнения этих операций. Поэтому компилятор оставляет за собой право вычислять такие выражения в любом
порядке, даже в случае, когда в выражении имеются скобки, специфицирующие порядок вычисления.

Операция последовательного вычисления, логические операции И и ИЛИ, условная операция и операция вызова функции гарантируют определенный порядок
вычисления своих операндов. Операция последовательного вычисления обеспечивает вычисление своих операндов по очереди,
слева направо (запятая, разделяющая аргументы в вызове функции, не является операцией последовательного вычисления и 
не обеспечивает таких гарантий). Гарантируется лишь то, что к моменту вызова функции все аргументы уже вычислены.

Условная операция вычисляет сначала свой первый операнд, а затем, в зависимости от его значения, либо второй, либо третий.

Логические операции также обеспечивают вычисление своих операндов слева направо. 
Однако логические операции вычисляют минимальное число операндов, необходимое для определения результата выражения.
Таким образом, второй операнд выражения может вообще не вычисляться.
