

# Переменные и с чем их едят

## _Понятия времени жизни и области видимости переменных._

Время жизни переменной может быть глобальным и локальным. Переменная с глобальным временем жизни характеризуется тем, что в течение всего времени выполнения программы с ней ассоциирована ячейка памяти и значение. Переменной с локальным временем жизни выделяется новая ячейка памяти при каждом входе в блок, в котором она определена или объявлена.

Область видимости объекта определяет, в каких участках программы допустимо использование имени этого объекта.

- Глобальные переменные

Глобальные переменные видны всей программе и могут использоваться любым участком кода. Они хранят свои значения на протяжении всей работы программы. Глобальные переменные создаются путем объявления вне функции. К ним можно получить доступ в любом выражении, независимо от того, в какой функции находится данное выражение.

В следующей программе можно увидеть, что переменная xyz объявлена вне функций. Она объявляется перед функцией `main()`. Она может быть помещена в любое место до первого использования, но не внутри функции.

```c++
#include <stdio.h>

int main(void)
{
   xyz = 100;
   printf("%d", xyz);
   return 0; 
}

int xyz; // xyz является глобальной переменной 
```

- Локальные переменные

С глобальными переменными все просто, используй их когда угодно и где угодно, но что тогда с локальными?

Переменные, объявляемые внутри функций или блоков, называются локальными переменными. С локальными переменными могут работать только операторы, находящиеся в блоке, где данные переменные объявлены. Вне этого блока локальные переменные неизвестны.
Следует помнить, что блок кода начинается открытием фигурной скобки и заканчивается закрытием фигурной скобки.

```c++

int main(void){
   int x = 1; // объявление первой локальной переменной х внутри функции
   printf("%d\n", x);
   {
      int x = 2; // объявление новой переменной x внутри отдельного блока
      printf("%d\n", x);

   } 
  // после выхода из блока из памяти стираются все переменные, выделенные в этом блоке
  for(int i = 1; i <= 3; ++i){
      int x = i;
      printf("%d\n", x);
  }
  printf("%d\n", x);
}
```
После выполнения данной программы мы получим:
```
1
2
123
1
```
Область видимости имени начинается в точке объявления, точнее, сразу после объявителя, но перед инициализатором. Поэтому допускается использование имени в качестве инициализирующего значения для себя самого.
```c++ 
int x = x; // Странно, но возможно
```

## Модификаторы области видимости и времени жизни переменных

- Модификатор `extern`


Модификатор extern предназначен для использования в данном программном модуле объекта, который объявлен в другом программном модуле.

Предположим, что наша программа состоит из двух файлов, в одном из которых объявлена глобальная переменная gl.
```c++
int gl = 5;
```
И нам необходимо использовать ее в части кода, находящейся в другом файле. Для этого нам необходимо указать, что эта глобальная переменная является внешней:
```c++
extern int gl;
```
>`extern` должен применяться во всех файлах, где используется переменная, кроме того файла, где она была объявлена изначально

- Модификатор `static`

Когда `static` применяется к локальной переменной, это приводит к тому, что компилятор создает долговременную область для хранения переменной почти таким же способом, как это делается для глобальной переменной. Ключевое различие между статической локальной и глобальной переменными заключается в том, что статическая локальная переменная остается известной только в том блоке, в котором она была объявлена.


Допустим у нас имеется программа:
```c++
void func(){
   static int x; // переменная х будет существовать до окончания программы
   x++;          // но обратиться к ней мы можем только внутри данной функции
   printf("%d\n", x);
}

int main(void){
   for (int i = 0; i < 3; ++i){
      func();
   }
}
```
И на выходе мы получим:
```
1
2
3
```
> Переменная, объявленная модификатором `static` может быть инициализирована константным выражением или нулевым значением(по умолчанию):
> объявления static int i = 0 и static int i эквивалентны

- Модификатор `register`

Для компилятора модификатор `register` означает предписание обеспечить такое хранение соответствующей переменной, чтобы доступ к ней можно было получить максимально быстро. Обычно переменная в этом случае будет храниться либо в регистре центрального процессора, либо в кэше. Вероятно, вы знаете, что доступ к регистрам ЦП (или к кэш-памяти) принципиально быстрее, чем доступ к основной памяти компьютера. Таким образом, переменная, сохраняемая в регистре, будет обслужена гораздо быстрее, чем переменная, сохраняемая, например, в оперативной памяти. Поскольку скорость, с которой к переменным можно получить доступ, определяет, по сути, скорость выполнения вашей программы, для получения удовлетворительных результатов программирования важно разумно использовать спецификатор `register`.

Спецификатор `register` в объявлении переменной означает требование оптимизировать код для получения максимально возможной скорости доступа к ней.
```c++
   register int x;
```

>Формально спецификатор `register` представляет собой лишь запрос, который компилятор вправе проигнорировать. Количество регистров (или устройств памяти с малым временем выборки) ограничено, причем для разных сред оно может быть различным. Поэтому, если компилятор исчерпает память быстрого доступа, он будет хранить register-переменные обычным способом. В общем случае неудовлетворенный register-запрос не приносит вреда, но, конечно же, и не дает никаких преимуществ хранения в регистровой памяти.
