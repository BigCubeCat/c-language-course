# Выравнивание памяти

## Введение
>«Программирование на C подобно быстрому танцу на полу, только что натёртом воском, среди людей с острыми бритвами в руках.»  
_Waldi Ravens. Программист._

Сразу к делу.
Давайте рассмотрим некоторую структуру:
```c++
struct  TList {
    int Value;
    struct  TList*  Next;
    int Freq;
};
```
Допустим, что нам стало интересно, сколько памяти эта структура занимает. Попробуем прикинуть. Размер структуры, скорее всего, определяется суммой размеров полей структуры. Тогда ожидаем, что ``` sizeof(TList) == szieof(Value) + sizeof(Next) + sizeof(Freq)```
Проверим:
```c++
#include  <stdio.h>
#include  <stdlib.h>

struct  TList {
    int Value;
    struct  TList*  Next;
    int Freq;
};

typedef  struct  TList  TList;

int  main(void) {
    TList list = {0, 0, 0};
    if (sizeof(list) ==  sizeof(list.Value) +  sizeof(list.Next) + sizeof(list.Freq)) {
        printf("You are right!\n");
    } else {
        printf("Ahaha, sorry, Bro\n");
    }
    return EXIT_SUCCESS;
}
```
Запускаем:
```c++
$ ./ahaha.exe
Ahaha, sorry, Bro
```
Ага. Можно предположить, что помимо размеров полей в структуре хранятся дополнительные служебные данные. Но, наверное, от перестановки полей в структуре ничего поменяться не должно. Проверим:
```c++
#include  <stdio.h>
#include  <stdlib.h>

struct  TList1 {
    int Value;
    struct  TList*  Next;
    int Freq;
};

struct  TList2 {
    struct  TList*  Next;
    int Freq;
    int Value;
};

typedef  struct  TList  TList;

int  main(void) {
    TList1 list1 = {0, 0, 0};
    TList2 list2 = {0, 0, 0};
    if (sizeof(list1) ==  sizeof(list2)) {
        printf("You are right!\n");
    } else {
        printf("Ahaha, sorry, Bro\n");
    }
    return EXIT_SUCCESS;
}
```
Вывод:
```
$ ./ahaha.exe
Ahaha, sorry, Bro
```
Возникли вопросы? Если да, то отлично.

## Ответики
Всё дело в выравнивании памяти. Вот так просто и без интриги. Что это такое? Правило звучит примерно так: адреса переменных типа T кратны sizeof(T). То есть типы размером в один байт могут находиться в любой ячейке, типы в два байта - только в четных ячейках, типы с размерностью в 4 байта - в ячейках с адресами, кратными 4, и т.д. Тогда в нашем примере указатель Next должен лежать в ячейке с адресом, кратным 8 (для 64-битной архитектуры). Примерное представление структуры в памяти:
```
|----Value----| |----Space----| |----------Next----------||-----Freq-----|
```
Space нужен как раз для выравнивания адреса Next.  Так как sizeof(Value) == sizeof(Freq) == 4, то разумно предположить, что при объявлении поля Next в начале структуры  мы получим более компактное расположение и сэкономим маленько байтиков. 
Проверяем:
```c++
#include  <stdio.h>
#include  <stdlib.h>

struct  TList1 {
    int Value;
    struct  TList*  Next;
    int Freq;
};

struct  TList2 {
    struct  TList*  Next;
    int Value;
    int Freq;
};

typedef  struct  TList  TList;

int  main(void) {
    TList1 list1 = {0, 0, 0};
    TList2 list2 = {0, 0, 0};
    if (sizeof(list1) >  sizeof(list2)) {
        printf("You are right!\n");
    } else {
        printf("Ahaha, sorry, Bro\n");
    }
    return EXIT_SUCCESS;
}
```
Вывод:
```
$ ./not_ahaha.exe
You are right!
```
Красота. Научились упаковывать структуры. Или нет? Правило упаковки примерно такое - объявляем поля от большей размерности к меньшей. Таким образом мы минимизируем число выравнивающих неиспользуемых байтов.
 ## Плюшки компиляторов
Минимизировать выравнивающие байты просто перестановкой строк с объявлениями полей - круто. А если я хочу в точности получить структуру с размером, равным суммарной размерности полей. Хочите так? Он есть у меня:
```c++
#include  <stdio.h>
#include  <stdlib.h>

#pragma  pack(push, 1)
struct  TList {
    int Value;
    struct  TList*  Next;
    int Freq;
};
#pragma  pack (pop)

typedef  struct  TList  TList;

int  main(void) {
    TList list = {0, 0, 0};
    if (sizeof(list) ==  sizeof(list.Value) +  sizeof(list.Next) + sizeof(list.Freq)) {
    printf("You are right!\n");
    printf("%d", sizeof(list));
    } else {
        printf("Ahaha, sorry, Bro\n");
    }
    return EXIT_SUCCESS;
}
``` 
Вывод:
```c++
$ ./not_ahaha.exe
You are right!
16
``` 
Вот это мощь. Запаковали структуру по полной. А что в замен? Ведь в жизни (а в частности и в Си) ничего просто так не бывает. Тут мы вынуждены расплачиваться скоростью работы со структурой. Почему? Отличный и своевременный вопрос.
## Катарсис
Выравнивание памяти было придумано отнюдь не для того, чтобы в пользовательские структуры докидывать кучу выравнивающих ненужных байт, тем самым увеличивая расходы на ОЗУ. Реальный смысл примерно таков:
процессоры (железяки) на аппаратном уровне работают не с байтами, а с так называемыми машинными словами (обычно от 2 байт и больше). Для получения   данных процессору желательно обращаться только по адресам, кратным машинному слову, поэтому если вдруг наша переменная в памяти не выравнена по адресам, то её считывание необходимо проделать в несколько приемов. 
|-------Machine_word1-------||-------Machine_word2-------|
|-----------------------------|-----Value-----|---------------------|
Тут сначала произойдет чтение в память процессора блока памяти Machine_word1 для получения первой части Value,а затем произойдет чтение Machine_word2 для получения второй части Value. Очевидно, что при выравненном адресе Value мы бы обошлись одним чтением, что оптимальнее по времени. 
Сама же необходимость выравнивания слов в памяти на уровне процессора, вероятно, продиктована векторизацией вычислений. Например, для сложения 3-х пар (x1 + x2, y1 + y2, z1 + z2)  чисел нет необходимости делать это в три подхода, достаточно собрать числа по тройкам в некоторый вектор, а затем единожды сложить векторы. Это значительно упрощает и ускоряет вычисления. А вычисления такого типа возможны, если допустимо быстро и просто из нескольких чисел собрать вектор. Для этого нам выравнивание и нужно - нежели что-то читать из памяти в несколько проходов и собирать в машинные слова, процессор просто в каждую часть вектора поместит соответствующее машинное слово, соберет два вектора машинных слов, проделает с ними некоторую операцию (сложение, например) как над единым целым, а потом снова поделит на машинные слова и выдаст результаты. Как-то так. Вроде, разобрались. Берегите себя и своих близких.
