# Переполнение  буфера
Так как фактически строка в Си являются массивом с детерминирующим символом на конце, все проблемы работы с массивами наследуются и строками. 
Так, например, возможен доступ по произвольному адресу при обращении к элементу массива по индексу.
```c++
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    char str1[10] = "Hello";
    char str2[10] = "Good Bye";
    int index = 0;
    while (scanf("%d", &index) == 1) {
        printf("\nIndex: %d\t, Value: %c", index, str[index]);
    }
    return EXIT_SUCCESS;
}
```
При попытке обратиться к допустимым индексам получаем прозаичный результат:
```
./IndexAccess.exe
Index: 0, Value: H
Index: 1, Value: e
Index: 2, Value: l
Index: 3, Value: l
Index: 4, Value: o
Index: 5, Value:
$ ^C
```
Давайте попробуем что-то поинтереснее (научный метод тыка):
```
./IndexAccess.exe
Index: -10, Value: G
Index: -9, Value: o
Index: -8, Value: o
Index: -7, Value: d
Index: -6, Value:
Index: -5, Value: B
Index: -4, Value: y
Index: -3, Value: e
Index: -2, Value:
Index: -1, Value:
Index: 0, Value: H
$ ^C
```
Вот мы и дотыкались. В соответствии с логикой написанного кода, программа должна выдавать некоторый символ (элемент строки) в зависимости от индекса. Но так как фактически строка ~ массив ~ указатель на область памяти, то верно:
```c++
str1[index] ~ *(str1 + index)
```
То есть происходит доступ к ячейке памяти, которая смещена от адреса str1 (он же - адрес первой ячейки в массиве) на sizeof(str1[0]) * index байт. (Да, уже можно открыть форточку, если душно). Таким образом, при (-10 <= index < 0) мы получили доступ к памяти, которая лежит фактически перед str1, то есть к элементам массива str2. (str2, хоть и объявлена позже str1, лежит перед ней в памяти, потому что это стек (ну и вообще из-за архитектуры процессора, скорее всего)) Уже открыли форточку? Отлично. 
Очевидно, что если мы можем считать данные по произвольному индексу, то и записать их при наличии соответствующей функции не составит труда (реализацию данного функционала оставлю в качестве упражнения читателю(o_0) ).
Другой пример:
```c++
#include  <stdio.h>
#include  <stdlib.h>

int  main(void) {
    const  char importantInfo[] =  "You are cool";
    char  name[10] = {0};
    printf("Enter your name, please\n");
    scanf("%s", name);
    printf("%s, %s", name, importantInfo);
    return EXIT_SUCCESS;
}
``` 
Суть работы программы, я думаю, ясна. Может быть непонятным использование ключевого слова cosnt. Оно предназначено для закрытия на доступа на запись (режим read-only). То есть если ниже объявления написать 
```c++
importantInfo[0] = 'y';
```
То получим ошибку на этапе компиляции.
Теперь попробуем воспользоваться программой:
```c++
$ ./cool.exe
Enter your name, please
Yuriy
Yuriy, You are cool
```
Вроде, все в порядке. Попробуем что побольше:
```c++
$ ./cool.exe
Enter your name, please
IloveChurkin
IloveChurkin, in
```
Хоба. Вот это чудеса. Мы изменили строку, к которой по логике программы доступ иметь не должны. Давайте ещё попробуем:
 ```c++
 $ ./cool.exe
 Enter your name, please
aaaaaaaaaaaaaaaaaaaaaa
Segmentation fault
 ```
 Вот мы успешно программу и положили. Почему так. Тут все дело в организации памяти программы. (Открывайте вторую форточку).
 Короче. У процессора есть регистры - это маленькие блоки памяти, к которым процессор умеет обращаться суперлупермега быстро. Есть регистры общего назначения (под всякие переменные), а есть регистры для системных нужд, например, указатель на адрес возврата (реально хранит адрес того места в коде, куда нужно вернуться после выполнения некоторой подпрограммы). И, скорее всего, мы только что с вами перезаписали этот самый регистр каким-то мусорным значением, программа попыталась перейти по мусорному адресу и продолжить выполнение программы, но у нее, слава Богу, ничего не получилось и она упала (на самом деле нет, но об этом дальше).
Давайте разовьем этот мотив: 
```c++
#include  <stdio.h>
#include  <stdlib.h>

int  function5() {
    int ret =  5;
    char str[] =  "str";
    scanf("%s", str);
    return ret;
}

int  main(void) {
    printf("%d", function5());
    return EXIT_SUCCESS;
}
```
Вывод:
```c++
$ ./hack.exe
aa
5
// работает
$ ./hack.exe
aaa
5
// работает
$ ./hack.exe
aaaaa
97
// опаньки...
```
Очевидно, что мы перезаписали данные на стеке, и теперь в переменной ret лежит не 5, а 97(97 лежит там, потому что мы перезаписали младший байт 4-х байтного int-а и поместили туда код символа 'a' == 97). Хочу положить в ret 126. Да как угодно:
```c++
$ ./hack.exe
ffff~
126
```
Ладно, хватит черной магии. К слову, никакой магии нет - всё это можно и нужно попробовать проделать своими руками. (Если что-то не будет получаться, вероятно, необходимо будет скомпилировать программу с ключом, отключающим защиту стека от переполнения - так называемую стековую канарейку - в gcc нужен ключ -fno-stack-protector - про это подробнее тут:
https://www.youtube.com/watch?v=JqUgfyH7CjI). А на сегодня всё, закрывайте форточки, чтобы Вас не продуло, и берегите свой код от переполнений.

