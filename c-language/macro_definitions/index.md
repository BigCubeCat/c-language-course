# Препроцессор. Макроопределения

**Препроцессор** — это специальная программа, являющаяся частью компилятора языка Си. Она предназначена для предварительной обработки текста программы. Препроцессор позволяет включать в текст программы файлы и вводить макроопределения.
Работа препроцессора осуществляется с помощью специальных директив (указаний). Они отмечаются знаком решетка #. По окончании строк, обозначающих директивы в языке Си, точку с запятой можно не ставить.

## Основные директивы препроцессора

```c++
#include  //вставляет текст из указанного файла
#define //задаёт макроопределение (макрос) или символическую константу
#undef //отменяет предыдущее определение
#if //осуществляет условную компиляцию при истинности константного выражения
#ifdef //осуществляет условную компиляцию при определённости символической константы
#ifndef //осуществляет условную компиляцию при неопределённости символической константы
#else //ветка условной компиляции при ложности выражения
#elif //ветка условной компиляции, образуемая слиянием else и if
#endif //конец ветки условной компиляции
#line //препроцессор изменяет номер текущей строки и имя компилируемого файла
#error //выдача диагностического сообщения
#pragma //действие, зависящее от конкретной реализации компилятора.
```
## Директива #define

Директива `#define` позволяет вводить в текст программы константы и макроопределения.
Общая форма записи:
```c++
#define Идентификатор Замена
```

Поля ***Идентификатор*** и ***Замена*** разделяются одним или несколькими пробелами.
Директива `#define` указывает компилятору, что нужно подставить строку, определенную аргументом ***Замена***, вместо каждого аргумента ***Идентификатор*** в исходном файле. **Идентификатор** не заменяется, если он находится в комментарии, в строке или как часть более длинного идентификатора.

```c++
#include <stdio.h>
#define A 3
int main()
{
  printf("%d + %d = %d", A, A, A+A); // 3 + 3 = 6
  return 0;
}
```

В зависимости от значения константы компилятор присваивает ей тот или иной тип. С помощью суффиксов можно переопределить тип константы:
```c++
#define A 280U   // unsigned int
#define B 280UL  // unsigned long int
#define C 280    // int (long int)
#define D 280L   // long int
#define K 28.0   // double
#define L 28.0F  // float
#define M 28.0L  // long double
```

Вторая форма синтаксиса определяет макрос, подобный функции, с параметрами. Эта форма допускает использование необязательного списка параметров, которые должны находиться в скобках. После определения макроса каждое последующее вхождение
```c++
#define Идентификатор(аргумент1, ..., агрументn) Замена
```
Например:
```c++
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define PI 3.14159265
#define SIN(x) sin(PI*x/180) //x - параметр
int main()
{
  int c;
  system("chcp 1251");
  system("cls");
  printf("Введите угол в градусах: ");
  scanf("%d", &c);
  printf("sin(%d)=%lf", c, SIN(c));
  return 0;
}
```

Однако при использовании таких макроопределений следует соблюдать осторожность, например:
```c++
#include <stdio.h>
#define sum(A,B) A+B
int main()
{
  int a, b, c, d;
  a = 3; b = 5;
  c = (a + b) * 2; // c = (a + b)*2
  d = sum(a, b) * 2; // d = a + b*2;
  printf(" a = %d\n b = %d\n", a, b);
  printf(" c = %d \n d = %d \n", c, d);
  return 0;
}
```
Отличием таких макроопределений от функций в языке Си является то, что на этапе компиляции каждое вхождение идентификатора замещается соответствующим кодом. Таким образом, программа может иметь несколько копий одного и того же кода, соответствующего идентификатору. В случае работы с функциями программа будет содержать 1 экземпляр кода, реализующий указанную функцию, и каждый раз при обращении к функции ей будет передано управление.

По умолчанию текст макроопределения должен размещаться на одной строке. Если требуется перенести текст макроопределения на новую строку, то в конце текущей строки ставится символ "\\\".

Кроме того, директива #define позволяет замещать часть идентификатора. Для указания замещаемой части используется ##

```c++
#include <stdio.h>
#define SUM(x,y) (a##x + a##y)
int main()
{
  int a1 = 5, a2 = 3;
  printf("%d", SUM(1, 2)); // (a1 + a2)
  return 0;
}
```
